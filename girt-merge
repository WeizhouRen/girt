#!/bin/dash

# test .girt exists
if ! test -d .girt
then
	echo "$0: error: girt repository directory .girt not found"
	exit 1
fi

# test incorrect input
if ! test $# = 3 || ! test $2 = "-m" || echo $1 | grep -E -q '^-' || echo $3 | grep -E -q '^-'
then
    echo "usage: girt-merge <branch|commit> -m message"
    exit 1
fi

# get current branch
branch=$( cat .girt/branch )
get_last_commit_number() 
{
    number=0
    while read -r record
    do
        commit=$(echo "$record" |cut -d' ' -f1)
        branch=$(echo "$record" |cut -d' ' -f2)
        if test $branch = $1
        then
            number=$(echo $commit)
        fi
    done < .girt/commit
    echo $number
}

get_common_commit()
{
    common=0
    while test -d .girt/$1/commit_$common && test -d .girt/$2/commit_$common
    do
        common=$((common + 1))
    done
    echo $((common - 1))
}
# get incoming branch or commit
merge_message="$3"
cur_repo=.girt/$branch/repository
cur_index=.girt/$branch/index
cur_wrk=.girt/$branch/working
cur_logs=.girt/$branch/logs
mkdir tmp-merged
if echo $1 | grep -E -q '^[0-9]$'
then
    
    ############## DEAL WITH MERGE COMMIT ###################
    # first arg is all number => commit number
    # Steps:
    #   1. find out branch the commit conducted
    #   2. get commit files in target commit folder and load into current 
    merge_commit=$1

else
    ############## DEAL WITH MERGE BRANCH ###################
    # first arg is not a number => branch name
    # Steps:
    #   1. get bifurcation point of two branches
    #   2. check if last commit number in current branch is larget than the bifurcation point
    tar_repo=.girt/$1/repository
    tar_index=.girt/$1/index
    tar_wrk=.girt/$1/working 
    tar_logs=.girt/$1/logs
    cur_lst_cmt=`get_last_commit_number $branch`
    tar_lst_cmt=`get_last_commit_number $1`
    common=`get_common_commit $branch $1`
    if test $common -eq $cur_lst_cmt
    then
        # FAST FORWARD: no commit created
        rm -rf $cur_repo $cur_index $cur_wrk *
        cp -R $tar_repo $cur_repo
        cp -R $tar_index $cur_index
        cp -R $tar_wrk $cur_wrk
        cp $tar_logs $cur_logs
        # load file to current working directory
        for file in $cur_wrk/*
        do
            cp -R $file .
        done
        echo "Fast-forward: no commit created"
    else
        # For the same file in two branches, if one of them is same as the file in the bifuraction commit point
        # file can be merged => create tmp directory to save the merged repo, keep the last modified file
        for cur_cmt_file in $cur_repo/*
        do
            file=$(echo $cur_cmt_file |rev |cut -d'/' -f1 |rev)
            common_cmt_file=".girt/${branch}/commit_${common}/${file}"
            tar_cmt_file="${tar_repo}/${file}"
            tmp_file="tmp-merged/${file}"

            # CASE VII: file in current repo does not exist in target repo and common repo
            #           which means the file is added in current commit => save to tmp
            if ! test -f $tar_cmt_file && ! test -f $common_cmt_file
            then
                cp $cur_cmt_file $tmp_file
            
            # CASE I:   file only edited in target branch, save target file into tmp
            elif cmp -s $cur_cmt_file $common_cmt_file && ! cmp -s $tar_cmt_file $common_cmt_file
            then
                cp $tar_cmt_file $tmp_file
            # CASE II:  file only edited in current branch, save current file into tmp
            elif ! cmp -s $cur_cmt_file $common_cmt_file && cmp -s $tar_cmt_file $common_cmt_file
            then
                cp $cur_cmt_file $tmp_file
            # CASE III: files are still same, save one of them
            elif cmp -s $cur_cmt_file $tar_cmt_file
            then
                cp $cur_cmt_file $tmp_file
            # CASE IV:  files have different edition => ERROR: cannot merge
            else
                echo "girt-merge: error: can not merge"
                exit 1
            fi
        done

        for tar_cmt_file in $tar_repo/*
        do
            file=$(echo $tar_cmt_file |rev |cut -d'/' -f1 |rev)
            common_cmt_file=".girt/${branch}/commit_${common}/${file}"
            cur_cmt_file="${cur_repo}/${file}"
            tmp_file="tmp-merged/${file}"
            # CASE V:   file created in target branch and does not exist in current branch
            #           will be saved into tmp
            if ! test -f $common_cmt_file
            then
                cp $tar_cmt_file $tmp_file
            # else ! test -f $common_cmt_file && 
            fi
            # CASE VI:  file is deleted from current branch, but still exists in target branch
            #           should not be merged into tmp => do nothing
        done

        # update files in current repository folder
        rm -rf $cur_repo
        cp -R tmp-merged $cur_repo
        # update staged file
        rm -rf $cur_index
        cp -R tmp-merged $cur_index
        # update file in current working directory
        for file in *
        do
            if test $file = "tmp-merged"; then continue; fi
            rm -rf $file
        done
        
        for file in tmp-merged/*
        do
            cp $file .
        done
        rm -rf tmp-merged
        # save commit version
        commit_no=$( cat .girt/commit |wc -l)
        commit_dir=".girt/${branch}/commit_${commit_no}"
        cp -R tmp-merged $commit_dir
        # update commit log and current log
        echo "Committed as commit ${commit_no}"
        content="${commit_no} ${merge_message}"
        echo "${content}" >> .girt/${branch}/logs
        echo "${commit_no} ${branch}" >> .girt/commit
    fi
fi



